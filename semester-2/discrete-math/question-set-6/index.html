<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css" />
    <title>Document</title>
</head>
<body>
    <header class="header">
        <div class="top-bar">
            <div class="top-bar__column top-bar__column_left">
                <div class="top-bar__element">Question Set #6</div>
                <div class="top-bar__element">Combinatorics</div>
            </div>
            <div class="top-bar__column top-bar__column_right">
                <div class="top-bar__element">Discrete M∀th</div>
                <div class="top-bar__element">Spring 2022</div>
            </div>
        </div>
    </header>
    <div class="container">
        <section class="task task_1">
            <div class="condition">
                <img src="./img/condition-1.png"/>
            </div>
            <div class="solution">
                <p>Буква 'd' должна присутствовать в наших словах ровно один раз. Поэтому посчитаем количество подходящих нам слов без 'd' на k - 1 символ, а затем n способами добавим 'd'.</p>
                <p>Количество слов с алфавитом {a, b, c} на k - 1 символ равняется 3^(k - 1), так как на каждое место можно поставить любую букву.</p>
                <p>Но так как каждая буква должна встречаться как минимум один раз, а мы посчитали случаи без буквы 'a', без буквы 'b' и без буквы 'd', то тогда подсчитаем количество таких случаев, а затем вычтем из посчитанного выше числа.</p>
                <p>Случаи идентичны, поэтому посчитаем для одной любой буквы, а потом умножим на 3.</p>
                <p>Количество слов без буквы 'a' = 2^(k - 1), на любое место можно поставить одну из букв 'b' или 'c'.</p>
                <p>Аналогично с 'b' и 'c'.</p>
                <p>Но мы посчитали случаи, когда только одна буква, то есть нет сразу двух нужных нам букв, дважды. Например, слово из всех 'c'. Прибавим эти случаи, их по одному на каждую пару букв.</p>
                <p>Так же по формуле включения/исключения мы лишний раз прибавили случаи, когда у нас нет ни одной из 3 букв, но таких случаев у нас нет.</p>
                <p>Число таких слов с алвафитом {a, b, c} на k - 1 символ без повторений равняется 3^(k - 1) - 3 * 2^(k - 1) + 3 * 1 - 0.</p>
                <p>И теперь вспомним про букву 'd'. И для каждой расстановки буквы 'd' на одно из n мест мы подсчитываем количество слов, которое мы посчитали выше.</p>
                <p>То есть n * (3^(k - 1) - 3 * 2^(k - 1) + 3 * 1 - 0).</p>
                <span class="answer">Итого: 3 * n * (3^(k - 2) - 2^(k - 1) + 1)</span>
            </div>
        </section>
        <section class="task task_2">
            <div class="condition">
                <img src="./img/condition-2.png"/>
            </div>
            <div class="solution">
                <p>Пройдемся по всем числам и будем сравнивать их с n - если наше число больше n, то все хорошо. Если же нет, то будем умножать его на 2 до тех пор, пока оно не станет больше.</p>
                <p>Наше число при такой операции не превзойдет 2 * n, так как n при домножении на 2 = 2 * n, а производим эту операцию мы для чисел, не больших n.</p>
                <p>Итого у нас выходит (n + 1) чисел на множестве из n элементов. То есть по принципу Дирихле какие-то 2 элемента совпадают.</p>
                <p>Представим эти 2 числа в виде a * (2^k) и b * (2^l), независимо от того, домножали ли мы изначальное число, где a и b - исходные числа в первоначальном set-е, а k и l - количество раз, потребовавшихся для того, чтобы число стало больше n.</p>
                <p>Тогда одно из этих чисел (a или b) делит другое (b или a), потому что, либо k <= l, либо l <= k, причем одно больше другого в 2^(max(k; l) - min(k; l)) раз.</p>
            </div>
        </section>
        <section class="task task_3">
            <div class="condition">
                <img src="./img/condition-3.png"/>
            </div>
            <div class="solution">
                <p>Есть множество на n элементов, и требуется выбрать из него r элементов.</p>
                <p>Давайте разделим наше множество на 2 подмножества - на (n - m) и m элементов, соотвественно, где 0 ≤ m, r ≤ n.</p>
                <p>Пусть мы выберем любые k элементов из подмножества на (n - m) элементов. Тогда оставшиеся необходимые нам элементы мы доберем из второго подмножества на m элементов. Соотвественно, остается для добора (r - k) элементов.</p>
                <p>По правилу произведения мы умножим 2 числа, равных количеству сочетаний = <img src=""/>
                <p>Мы получили количество сочетаний только для одного случая - для одного значения k, а необходимо просуммировать все случаи.</p>
                <p>Итого, мы в начале условно разбиваем изначальное множество на 2 подмножества, а дальше варьируем количество взятых элементов из первого подмножества (количество взятых элементов из второго подмножества однозначно определяется).</p>
                <p>То есть, конечное число сочетаний равно сумме по количеству элементов, выбираемых из первого подмножества, произведения количества способов выбрать сами элементы из первого подмножества на количество способов выбрать оставшиеся элементы из второго.</p>           
                <span class="answer"></span>
            </div>
        </section>
        <section class="task task_4">
            <div class="condition">
                <img src="./img/condition-4.png"/>
            </div>
            <div class="solution">
                <p>Есть n мест. Назовем элемент фиксированной точкой для перестановки, если он стоит на своем месте.</p>
                <p>Тогда давайте возьмем i-й элемент, зафиксируем его (сделаем фиксированной точкой) и посчитаем, в скольких случаях он стоит на своем месте.</p>
                <p>То есть необходимо посчитать все перестановки, в которых наш i-й элемент - фиксированная точка.</p>
                <p>Так как i-й элемент фиксирован, а остальные элементы не имеют ограничений на свое расположение, то общее количество перестановок для нашего случая - (n - 1)!</p>
                <p>Давайте рассмотрим для каждого элемента то же самое. Для каждого случая количество перестановок равно (n - 1)!, а все таких случаев n.</p>
                <p>Значит, общая сумма количества фиксированных точек равна n * (n - 1)!, а это, в свою очередь, равняется n!</p>
                <p>При этом, мы посчитали некоторые случаи несколько раз, но, это ни на что не влияет, потому что необходимо посчитать общую сумму количества фиксированных точек, а не количество перестановок с фиксированными точками.</p>
                <p>То есть, например, (в нашем примере число стоит на своем месте, если оно равно номеру своего места) 1243 - случай, который будет посчитан более 1 раза, но при этом он дает 2 различных случая - (1 - фиксированная точка и 2 - фиксированная точка).</p>
            </div>
        </section>
        <section class="task task_5">
            <div class="condition">
                <img src="./img/condition-5.png"/>
            </div>
            <div class="solution">
                <p>Есть k мест, на каждое из которых мы можем разместить одну букву из алфавита мощностью n, при этом каждые 2 соседних элемента не должны быть равны.</p> 
                <p>Пронумеруем все места от 1 до n для удобства.</p>
                <p>Тогда возьмем 1 место и разместим на него любую из n элементов. Следовательно, его "сосед", - элемент на втором месте, может принимать любое значение, кроме значения элемента, расположенном на 1 месте.</p>
                <p>То есть (n - 1) значений.</p>
                <p>Далее рассмотрим 3 место. Аналогичная ситуация, на этом месте элемент может принмать любое значение, кроме значения его "соседа" на втором месте - (n - 1) значений.</p>
                <p>Аналогично с остальными местами до k. То есть размещаем на первом месте любое из n значений, и на остальных - любое из (k - 1). Так как для каждого значения важны другие значения, то используется метод произведения.</p>
                <span class="answer">Следовательно, ответ: n * (n - 1)^(k - 1)</span>
            </div>
        </section>
    </div>
    <footer class="footer">
        <div class="footer__text">
            Сделано студентами группы M3100 Соловьевым Романом и Ганиным Михаилом.
        </div>
    </footer>
</body>
</html>
